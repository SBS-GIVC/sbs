{"version":3,"file":"aiAssistantService-BWORHkI6.js","sources":["../../src/services/aiAssistantService.js"],"sourcesContent":["/**\n * AI-Powered SBS Assistant Service\n * Provides intelligent code suggestions, validation, and workflow assistance\n * Powered by Google Gemini AI\n */\n\nimport { callGemini } from './geminiService';\n\n// Load catalog data at runtime to keep the browser bundle lightweight.\nconst API_BASE_URL =\n  (typeof window !== 'undefined' && (window.SBS_API_URL || window.location.origin)) || '';\nlet SBS_CODES = {};\nlet CODES_ARRAY = [];\n\n// Common medical abbreviations for better matching\nconst MEDICAL_ABBREVIATIONS = {\n  'cbc': 'complete blood count',\n  'ct': 'computed tomography',\n  'mri': 'magnetic resonance imaging',\n  'ecg': 'electrocardiogram',\n  'ekg': 'electrocardiogram',\n  'us': 'ultrasound',\n  'xray': 'x-ray radiograph',\n  'cabg': 'coronary artery bypass graft',\n  'ptca': 'percutaneous transluminal coronary angioplasty',\n  'er': 'emergency room',\n  'icu': 'intensive care unit',\n  'iv': 'intravenous',\n  'bp': 'blood pressure',\n  'hba1c': 'glycated haemoglobin',\n  'tsh': 'thyroid stimulating hormone',\n  'ldl': 'low density lipoprotein',\n  'hdl': 'high density lipoprotein'\n};\n\n/**\n * AI SBS Assistant Class\n */\nclass AIAssistantService {\n  constructor() {\n    this.cache = new Map();\n    this.cacheTimeout = 1000 * 60 * 30; // 30 minutes\n    this.catalogPromise = null;\n    this.catalogFetchLimit = 200;\n  }\n\n  /**\n   * Get cache key\n   */\n  getCacheKey(type, query) {\n    return `${type}:${query.toLowerCase().trim()}`;\n  }\n\n  /**\n   * Check cache\n   */\n  getFromCache(key) {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  /**\n   * Set cache\n   */\n  setCache(key, data) {\n    this.cache.set(key, { data, timestamp: Date.now() });\n  }\n\n  async fetchCatalogPage(offset, limit) {\n    const url = `${API_BASE_URL}/api/sbs/codes?limit=${limit}&offset=${offset}`;\n    const response = await fetch(url, { headers: { Accept: 'application/json' } });\n    if (!response.ok) {\n      throw new Error(`SBS catalog fetch failed (${response.status})`);\n    }\n    return response.json();\n  }\n\n  async fetchFullCatalog() {\n    const url = `${API_BASE_URL}/api/sbs/codes/all`;\n    const response = await fetch(url, { headers: { Accept: 'application/json' } });\n    if (!response.ok) {\n      throw new Error(`SBS full catalog fetch failed (${response.status})`);\n    }\n    return response.json();\n  }\n\n  async ensureCatalogLoaded() {\n    if (CODES_ARRAY.length > 0) {\n      return;\n    }\n    if (this.catalogPromise) {\n      await this.catalogPromise;\n      return;\n    }\n\n    this.catalogPromise = (async () => {\n      const normalizeRows = (rows) =>\n        rows\n          .filter((row) => row?.code && row?.desc)\n          .map((row) => ({\n            code: row.code,\n            desc: row.desc,\n            descAr: row.descAr || null,\n            category: row.category || null,\n            chapter: row.chapter || null,\n            fee: Number(row.fee || 0)\n          }));\n\n      let all = [];\n      let loadError = null;\n      try {\n        const payload = await this.fetchFullCatalog();\n        all = normalizeRows(Array.isArray(payload.codes) ? payload.codes : []);\n      } catch (error) {\n        loadError = error;\n        // Backward compatible fallback for deployments without /api/sbs/codes/all.\n        let offset = 0;\n        let total = null;\n        try {\n          while (true) {\n            const payload = await this.fetchCatalogPage(offset, this.catalogFetchLimit);\n            const rows = Array.isArray(payload.codes) ? payload.codes : [];\n            if (rows.length === 0) break;\n            all.push(...normalizeRows(rows));\n            total = Number(payload.total || 0);\n            offset += rows.length;\n            if (total > 0 && offset >= total) break;\n          }\n        } catch (paginationError) {\n          loadError = paginationError;\n        }\n      }\n\n      if (all.length === 0 && loadError) {\n        console.warn('SBS catalog load unavailable, continuing with empty catalog:', loadError.message || loadError);\n      }\n\n      CODES_ARRAY = all;\n      SBS_CODES = Object.fromEntries(all.map((entry) => [entry.code, entry]));\n    })();\n\n    try {\n      await this.catalogPromise;\n    } finally {\n      this.catalogPromise = null;\n    }\n  }\n\n  /**\n   * Smart search with fuzzy matching and AI enhancement\n   */\n  async smartSearch(query, options = {}) {\n    const { limit = 20, category = null, includeAI = true } = options;\n    try {\n      await this.ensureCatalogLoaded();\n    } catch (error) {\n      console.warn('SBS catalog unavailable during smart search:', error);\n      return {\n        results: [],\n        source: 'unavailable',\n        query: query.toLowerCase(),\n        aiInsights: null\n      };\n    }\n    \n    // Expand abbreviations\n    let expandedQuery = query.toLowerCase();\n    for (const [abbr, full] of Object.entries(MEDICAL_ABBREVIATIONS)) {\n      expandedQuery = expandedQuery.replace(new RegExp(`\\\\b${abbr}\\\\b`, 'gi'), full);\n    }\n    \n    // Local search first\n    const localResults = this.localSearch(expandedQuery, category, limit);\n    \n    // If good results found locally, return them\n    if (localResults.length >= 5 && !includeAI) {\n      return {\n        results: localResults,\n        source: 'local',\n        query: expandedQuery\n      };\n    }\n    \n    // Enhance with AI if enabled and results are limited\n    if (includeAI && localResults.length < 10) {\n      try {\n        const aiSuggestions = await this.getAISuggestions(query, localResults);\n        \n        // Merge AI suggestions with local results\n        const mergedResults = this.mergeResults(localResults, aiSuggestions);\n        \n        return {\n          results: mergedResults.slice(0, limit),\n          source: 'ai_enhanced',\n          query: expandedQuery,\n          aiInsights: aiSuggestions.insights\n        };\n      } catch (error) {\n        console.warn('AI enhancement failed, using local results:', error);\n      }\n    }\n    \n    return {\n      results: localResults,\n      source: 'local',\n      query: expandedQuery\n    };\n  }\n\n  /**\n   * Local fuzzy search\n   */\n  localSearch(query, category = null, limit = 20) {\n    if (!CODES_ARRAY.length) return [];\n    const queryLower = query.toLowerCase();\n    const queryTerms = queryLower.split(/\\s+/).filter(t => t.length > 2);\n    \n    const scored = [];\n    \n    for (const code of CODES_ARRAY) {\n      // Skip if category filter doesn't match\n      if (category && code.category !== category) continue;\n      \n      let score = 0;\n      const descLower = code.desc.toLowerCase();\n      const catLower = (code.category || '').toLowerCase();\n      const codeLower = code.code.toLowerCase();\n      \n      // Exact code match - highest priority\n      if (codeLower === queryLower || codeLower.startsWith(queryLower)) {\n        score += 100;\n      }\n      \n      // Exact phrase match in description\n      if (descLower.includes(queryLower)) {\n        score += 50;\n      }\n      \n      // Individual term matches\n      for (const term of queryTerms) {\n        if (descLower.includes(term)) {\n          score += 10;\n          // Bonus for word start match\n          if (descLower.startsWith(term) || descLower.includes(` ${term}`)) {\n            score += 5;\n          }\n        }\n        if (catLower.includes(term)) {\n          score += 3;\n        }\n      }\n      \n      if (score > 0) {\n        scored.push({ ...code, score });\n      }\n    }\n    \n    // Sort by score descending\n    scored.sort((a, b) => b.score - a.score);\n    \n    return scored.slice(0, limit);\n  }\n\n  /**\n   * Get AI-powered suggestions\n   */\n  async getAISuggestions(query, existingResults = []) {\n    try {\n      await this.ensureCatalogLoaded();\n    } catch {\n      return { suggestions: [], insights: null };\n    }\n    const cacheKey = this.getCacheKey('suggestions', query);\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n    \n    const existingCodes = existingResults.slice(0, 5).map(r => `${r.code}: ${r.desc}`).join('\\n');\n    \n    const prompt = `You are a Saudi healthcare billing expert. Given the search query, suggest the most relevant SBS (Saudi Billing System) procedure codes.\n\nSearch Query: \"${query}\"\n\nAlready Found Codes:\n${existingCodes || 'None'}\n\nBased on the query, suggest additional specific SBS procedure codes that might be relevant. Consider:\n1. The medical context and intent\n2. Related procedures that are often performed together\n3. Alternative terminology the user might mean\n\nReturn JSON only:\n{\n  \"suggestions\": [\n    { \"code\": \"XXXXX-XX-XX\", \"desc\": \"Description\", \"confidence\": 0.95, \"reason\": \"Why this matches\" }\n  ],\n  \"insights\": \"Brief explanation of the search intent and recommendations\"\n}`;\n\n    try {\n      const response = await callGemini(prompt, \n        \"You are a senior Saudi medical coder expert in SBS V3.1. Return only valid JSON.\"\n      );\n      \n      // Parse JSON from response\n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[0]);\n        \n        // Validate and enhance suggestions with actual SBS data\n        const enhancedSuggestions = (parsed.suggestions || [])\n          .map(s => {\n            const actualCode = SBS_CODES[s.code];\n            if (actualCode) {\n              return {\n                ...actualCode,\n                confidence: s.confidence,\n                aiReason: s.reason,\n                source: 'ai'\n              };\n            }\n            return null;\n          })\n          .filter(Boolean);\n        \n        const result = {\n          suggestions: enhancedSuggestions,\n          insights: parsed.insights\n        };\n        \n        this.setCache(cacheKey, result);\n        return result;\n      }\n    } catch (error) {\n      console.error('AI suggestion error:', error);\n    }\n    \n    return { suggestions: [], insights: null };\n  }\n\n  /**\n   * Merge local and AI results\n   */\n  mergeResults(localResults, aiResults) {\n    const seen = new Set(localResults.map(r => r.code));\n    const merged = [...localResults];\n    \n    for (const suggestion of aiResults.suggestions || []) {\n      if (!seen.has(suggestion.code)) {\n        merged.push(suggestion);\n        seen.add(suggestion.code);\n      }\n    }\n    \n    return merged;\n  }\n\n  /**\n   * AI-powered claim validation\n   */\n  async validateClaim(claim) {\n    const items = claim.items || [];\n    \n    if (items.length === 0) {\n      return { valid: false, errors: ['No items in claim'], warnings: [], suggestions: [] };\n    }\n    \n    const itemsList = items.map((item, i) => \n      `${i + 1}. ${item.sbsCode} - ${item.description} (Qty: ${item.quantity}, Price: ${item.unitPrice} SAR)`\n    ).join('\\n');\n    \n    const prompt = `You are a Saudi healthcare claims auditor. Validate this claim for NPHIES submission.\n\nPatient ID: ${claim.patientId}\nService Date: ${claim.serviceDate}\nClaim Type: ${claim.claimType}\nTotal Amount: ${claim.totalAmount} SAR\n\nServices:\n${itemsList}\n\nCheck for:\n1. Missing required procedures (e.g., anesthesia with surgery)\n2. Duplicate or conflicting codes\n3. Unusual quantities or pricing\n4. Prior authorization requirements\n5. Bundle opportunities for cost savings\n\nReturn JSON:\n{\n  \"valid\": true/false,\n  \"errors\": [\"Critical issues that must be fixed\"],\n  \"warnings\": [\"Non-critical issues to review\"],\n  \"suggestions\": [\n    { \"type\": \"add\", \"code\": \"XXXXX-XX-XX\", \"reason\": \"Why to add\" },\n    { \"type\": \"bundle\", \"name\": \"Bundle Name\", \"savings\": 5000 },\n    { \"type\": \"priorAuth\", \"code\": \"XXXXX-XX-XX\", \"reason\": \"Why PA needed\" }\n  ],\n  \"summary\": \"Brief summary of validation\"\n}`;\n\n    try {\n      const response = await callGemini(prompt,\n        \"You are a Saudi healthcare claims auditor. Validate for CHI/NPHIES compliance. Return only JSON.\"\n      );\n      \n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        return JSON.parse(jsonMatch[0]);\n      }\n    } catch (error) {\n      console.error('Claim validation error:', error);\n    }\n    \n    return {\n      valid: true,\n      errors: [],\n      warnings: ['AI validation unavailable - please review manually'],\n      suggestions: [],\n      summary: 'Manual review required'\n    };\n  }\n\n  /**\n   * AI-powered diagnosis suggestion\n   */\n  async suggestDiagnoses(procedureCode, description) {\n    const cacheKey = this.getCacheKey('diagnosis', `${procedureCode}:${description}`);\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n    \n    const prompt = `You are a Saudi medical coder. Given this SBS procedure, suggest the most appropriate ICD-10 diagnosis codes.\n\nSBS Procedure: ${procedureCode}\nDescription: ${description}\n\nSuggest 3-5 commonly associated ICD-10 diagnosis codes with explanations.\n\nReturn JSON:\n{\n  \"diagnoses\": [\n    { \"code\": \"X00.00\", \"description\": \"Diagnosis description\", \"relevance\": \"high/medium/low\", \"reason\": \"Why associated\" }\n  ]\n}`;\n\n    try {\n      const response = await callGemini(prompt,\n        \"You are a Saudi medical coding expert. Suggest ICD-10 diagnoses for SBS procedures. Return only JSON.\"\n      );\n      \n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const result = JSON.parse(jsonMatch[0]);\n        this.setCache(cacheKey, result);\n        return result;\n      }\n    } catch (error) {\n      console.error('Diagnosis suggestion error:', error);\n    }\n    \n    return { diagnoses: [] };\n  }\n\n  /**\n   * AI-powered code mapping from internal hospital codes\n   */\n  async mapInternalCode(internalCode, description, context = {}) {\n    try {\n      await this.ensureCatalogLoaded();\n    } catch {\n      return {\n        sbsCode: null,\n        confidence: 0,\n        rationale: 'SBS catalogue is unavailable in this environment',\n        verified: false\n      };\n    }\n    const prompt = `You are a Saudi healthcare billing expert. Map this internal hospital code to the official SBS V3.1 code.\n\nInternal Code: ${internalCode}\nDescription: ${description}\nDepartment: ${context.department || 'Unknown'}\nFacility Type: ${context.facilityType || 'Hospital'}\n\nFind the most accurate SBS V3.1 code. The SBS code format is NNNNN-NN-NN.\n\nReturn JSON:\n{\n  \"sbsCode\": \"NNNNN-NN-NN\",\n  \"sbsDescription\": \"Official SBS description\",\n  \"confidence\": 0.95,\n  \"rationale\": \"Why this mapping is correct\",\n  \"alternatives\": [\n    { \"code\": \"NNNNN-NN-NN\", \"description\": \"Alternative\", \"confidence\": 0.85 }\n  ]\n}`;\n\n    try {\n      const response = await callGemini(prompt,\n        \"You are a Saudi SBS V3.1 coding expert. Map internal codes to official SBS codes. Return only JSON.\"\n      );\n      \n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const result = JSON.parse(jsonMatch[0]);\n        \n        // Verify the suggested code exists\n        if (result.sbsCode && SBS_CODES[result.sbsCode]) {\n          return {\n            ...result,\n            verified: true,\n            officialDesc: SBS_CODES[result.sbsCode].desc\n          };\n        }\n        \n        // If not found, search for similar\n        const similar = this.localSearch(result.sbsDescription || description, null, 5);\n        if (similar.length > 0) {\n          return {\n            sbsCode: similar[0].code,\n            sbsDescription: similar[0].desc,\n            confidence: 0.75,\n            rationale: 'AI suggestion validated against SBS catalogue',\n            verified: true,\n            alternatives: similar.slice(1, 4).map(s => ({\n              code: s.code,\n              description: s.desc,\n              confidence: 0.6\n            }))\n          };\n        }\n      }\n    } catch (error) {\n      console.error('Code mapping error:', error);\n    }\n    \n    // Fallback to local search\n    const results = this.localSearch(description, null, 5);\n    if (results.length > 0) {\n      return {\n        sbsCode: results[0].code,\n        sbsDescription: results[0].desc,\n        confidence: 0.6,\n        rationale: 'Matched by description keywords',\n        verified: true,\n        alternatives: results.slice(1).map(r => ({\n          code: r.code,\n          description: r.desc,\n          confidence: 0.5\n        }))\n      };\n    }\n    \n    return {\n      sbsCode: null,\n      confidence: 0,\n      rationale: 'No matching SBS code found',\n      verified: false\n    };\n  }\n\n  /**\n   * AI-powered prior authorization assistance\n   */\n  async assistPriorAuth(procedureCode, patientInfo, clinicalNotes) {\n    try {\n      await this.ensureCatalogLoaded();\n    } catch {\n      return {\n        justification: 'SBS catalogue unavailable; please provide manual prior-auth rationale.',\n        supportingPoints: ['Medical necessity', 'Clinical history'],\n        requiredDocuments: ['Clinical notes', 'Supporting diagnostics'],\n        estimatedApprovalTime: '48-72 hours',\n        approvalLikelihood: 'medium',\n        tips: ['Retry when catalog service is available']\n      };\n    }\n    const code = SBS_CODES[procedureCode];\n    \n    const prompt = `You are a Saudi healthcare prior authorization specialist. Help prepare a prior authorization request.\n\nProcedure: ${procedureCode} - ${code?.desc || 'Unknown procedure'}\nPatient Age: ${patientInfo.age || 'Unknown'}\nPatient Gender: ${patientInfo.gender || 'Unknown'}\nDiagnosis: ${patientInfo.diagnosis || 'Not specified'}\nClinical Notes: ${clinicalNotes || 'None provided'}\n\nGenerate a professional prior authorization justification that will maximize approval chances with Saudi insurance companies.\n\nReturn JSON:\n{\n  \"justification\": \"Detailed clinical justification text\",\n  \"supportingPoints\": [\"Key point 1\", \"Key point 2\"],\n  \"requiredDocuments\": [\"Document 1\", \"Document 2\"],\n  \"estimatedApprovalTime\": \"24-48 hours\",\n  \"approvalLikelihood\": \"high/medium/low\",\n  \"tips\": [\"Tip to improve approval chances\"]\n}`;\n\n    try {\n      const response = await callGemini(prompt,\n        \"You are a Saudi healthcare prior authorization expert. Help maximize PA approval chances. Return only JSON.\"\n      );\n      \n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        return JSON.parse(jsonMatch[0]);\n      }\n    } catch (error) {\n      console.error('PA assistance error:', error);\n    }\n    \n    return {\n      justification: 'Please provide clinical justification for this procedure.',\n      supportingPoints: ['Medical necessity', 'Patient history'],\n      requiredDocuments: ['Clinical notes', 'Lab results', 'Imaging reports'],\n      estimatedApprovalTime: '48-72 hours',\n      approvalLikelihood: 'medium',\n      tips: ['Include detailed clinical history', 'Attach supporting documentation']\n    };\n  }\n\n  /**\n   * Get all SBS codes (for browser)\n   */\n  getAllCodes() {\n    return CODES_ARRAY;\n  }\n\n  /**\n   * Get unique categories\n   */\n  getCategories() {\n    const categories = new Set();\n    for (const code of CODES_ARRAY) {\n      if (code.category) categories.add(code.category);\n    }\n    return Array.from(categories).sort();\n  }\n\n  /**\n   * Get code by ID\n   */\n  getCode(codeId) {\n    return SBS_CODES[codeId] || null;\n  }\n\n  /**\n   * Get total count\n   */\n  getTotalCount() {\n    return CODES_ARRAY.length;\n  }\n}\n\n// Export singleton instance\nexport const aiAssistant = new AIAssistantService();\n\n// Export class for testing\nexport { AIAssistantService };\n"],"names":["API_BASE_URL","SBS_CODES","CODES_ARRAY","MEDICAL_ABBREVIATIONS","AIAssistantService","type","query","key","cached","data","offset","limit","url","response","normalizeRows","rows","row","all","loadError","payload","error","total","paginationError","entry","options","category","includeAI","expandedQuery","abbr","full","localResults","aiSuggestions","queryLower","queryTerms","t","scored","code","score","descLower","catLower","codeLower","term","a","b","existingResults","cacheKey","existingCodes","r","prompt","jsonMatch","callGemini","parsed","result","s","actualCode","aiResults","seen","merged","suggestion","claim","items","itemsList","item","i","procedureCode","description","internalCode","context","similar","results","patientInfo","clinicalNotes","categories","codeId","aiAssistant"],"mappings":"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"}